# 005. Upload Test Cases - Implementation

## Overview

Users can upload TestRail XML exports to create test cases in bulk. Files are validated client-side and server-side, processed asynchronously via Celery, with real-time progress updates via WebSocket.

## Architecture

```
Browser (Alpine.js)
  |
  |-- form.submit() POST /projects/<id>/uploads/create/
  |       |
  |       v
  |   Django View (upload_create)
  |       |-- validates filename (.xml)
  |       |-- validates XML structure (suite root, case elements)
  |       |-- creates TestCaseUpload record
  |       |-- dispatches Celery task
  |       |-- redirects to upload_list
  |
  |-- WebSocket ws://host/ws/projects/<id>/uploads/
          |
          v
      UploadProgressConsumer
          |-- on connect: sends current state of all uploads
          |-- on group message: forwards progress to client
          |
      Celery Worker (process_xml_upload)
          |-- parses XML into ParsedTestCase list
          |-- bulk_create in batches of 50
          |-- sends progress via channel layer after each batch
          |-- deletes file after completion
```

## Files Modified/Created

### Models (`projects/models.py`)
- `TestCaseUpload` - upload record with status, progress, file reference
- `UploadStatus` - TextChoices: pending, processing, completed, failed, cancelled
- `ParsedTestCase` - dataclass for parsed XML case data
- `TestCase.upload` - nullable FK linking test cases to their source upload

### Services (`projects/services.py`)
- `create_upload()` - save file and create upload record
- `start_upload_processing()` - dispatch Celery task, save task_id
- `cancel_upload_processing()` - revoke Celery task, delete partial cases
- `delete_upload()` - cancel if processing, delete file, delete record
- `get_upload_for_project()` / `list_uploads_for_project()` - queries
- `validate_testrail_xml()` - check XML structure (suite root, case elements)
- `parse_testrail_xml()` - parse file into ParsedTestCase list
- `bulk_create_test_cases_from_parsed()` - batch insert with progress callback
- `is_valid_xml_filename()` - check .xml extension

### Celery Task (`projects/tasks.py`)
- `process_xml_upload` - shared_task with acks_late, reject_on_worker_lost
- Decomposed into: `_fetch_upload`, `_mark_processing`, `_process_upload_file`, `_mark_completed`, `_handle_failure`
- `_send_upload_progress()` - sends status via channel layer group
- On failure: rolls back partial test cases, sets error message

### WebSocket Consumer (`projects/consumers.py`)
- `UploadProgressConsumer` - sync WebSocket consumer
- Authenticates user and verifies project membership on connect
- Joins channel group `upload_{project_id}`
- `_send_current_state()` - on connect, sends current status of all uploads (fixes race condition where task completes during page reload)
- `upload_progress()` - forwards group messages to client

### Views (`projects/views.py`)
- `upload_list` - paginated upload history with drag-drop zone
- `upload_create` - validate and process uploaded file
- `upload_cancel` - cancel in-progress upload
- `upload_delete` - delete upload with cascade

### URLs (`projects/urls.py`)
- `<id>/uploads/` - upload_list
- `<id>/uploads/create/` - upload_create
- `<id>/uploads/<upload_id>/cancel/` - upload_cancel
- `<id>/uploads/<upload_id>/delete/` - upload_delete

### Templates
- `templates/projects/uploads.html` - upload page with Alpine.js component registered via `Alpine.data('uploadManager', ...)` in script block (avoids Django autoescape breaking JS)
- `templates/components/drag_drop_upload.html` - reusable drag-drop zone component
- `templates/projects/test_cases.html` - updated with upload filter dropdown and "Upload XML" link

### Routing (`projects/routing.py`)
- WebSocket route: `ws/projects/<int:project_id>/uploads/`

### ASGI (`auto_tester/asgi.py`)
- ProtocolTypeRouter with HTTP + WebSocket (AuthMiddlewareStack)

### Migration
- `0003_create_test_case_upload` - TestCaseUpload model + TestCase.upload FK

## Key Design Decisions

1. **Alpine.js in script block**: Inline `x-data` attributes get HTML-encoded by Django's autoescape (`<` becomes `&lt;`), breaking JS. Solved by registering the component via `Alpine.data()` in a `{% block extra_scripts %}` block.

2. **WebSocket initial state on connect**: The consumer sends current upload statuses immediately on connect. This handles the race condition where the Celery task completes during the page reload after form submission.

3. **Infinite reload prevention**: The JS tracks `previousStatus` before updating from WebSocket messages. Page only auto-reloads when status *changes* to a terminal state, not when an already-completed upload is re-reported.

4. **No explicit queue on task**: Celery's default queue is `"celery"`, not `"default"`. The task omits the `queue` parameter to use the default.

5. **File deleted after processing**: The uploaded XML file is deleted from storage after successful parsing, per spec constraint.

6. **Batch processing**: Test cases are bulk_created in batches of 50 with progress callback after each batch, enabling real-time progress updates.

## Test Coverage

176 tests total covering:
- XML validation (malformed, wrong root, no cases)
- XML parsing (fields, HTML entities, edge cases)
- Bulk creation with batching
- Upload CRUD views (create, list, cancel, delete)
- Service layer functions
- Admin configuration
- Celery task lifecycle (success, failure, missing upload)
- WebSocket consumer (connect, disconnect, auth, progress)
