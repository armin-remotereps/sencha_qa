# 010. Interactive Commands

## Description

When the AI agent executes shell commands on the remote machine via `execute_command`, any command that prompts for user input (e.g., `sudo`, `apt-get install`, SSH fingerprint confirmation, config wizards) hangs indefinitely because `subprocess.run(capture_output=True)` has no stdin support. The system needs to detect when a running process expects input, allow the AI agent to send that input, and receive the subsequent output — all over the existing WebSocket channel.

## Problem

Current `execute_command` flow:
1. Agent calls `execute_command(command="sudo apt install nginx")`
2. Server dispatches `RUN_COMMAND` to controller client
3. Controller runs `subprocess.run(command, shell=True, capture_output=True)`
4. Process blocks waiting for password input on stdin
5. Server-side timeout fires → `ControllerActionError("Timed out")`
6. Agent sees timeout, cannot complete the test case

This affects every command that needs interactive input: `sudo`, `apt install` (without `-y`), `ssh` (host key confirmation), `passwd`, `mysql` (password prompt), configuration wizards, etc.

## Requirements

### R1: Start an interactive command session
- The agent can start a command in an interactive PTY session instead of `subprocess.run`
- The controller client spawns the process via `pexpect.spawn()` (which allocates a PTY)
- The controller immediately begins streaming output chunks back to the server
- The server returns the session ID + initial output to the agent

### R2: Send input to a running session
- The agent can send text input (including newlines) to a running interactive session
- The controller writes the input to the PTY's stdin
- The controller collects and returns output produced after the input was sent
- The agent receives the new output to decide its next action

### R3: Graceful session lifecycle
- Sessions auto-terminate when the underlying process exits
- The agent can explicitly terminate (kill) a running session
- Sessions have a maximum lifetime timeout (configurable, default: 5 minutes)
- Only 1 active interactive session per project at a time (to keep things simple)
- When a session ends (naturally or via kill), the final output + exit code are returned

### R4: Non-breaking change
- Existing `execute_command` tool remains unchanged for simple non-interactive commands
- The new interactive tools are additive — two new agent tools alongside the existing one
- No changes to the existing `RUN_COMMAND` / `COMMAND_RESULT` protocol messages

### R5: AI agent integration
- Two new agent tools: `start_interactive_command` and `send_command_input`
- The agent loop system prompt is updated to document when to use interactive vs regular commands
- The agent decides which tool to use based on the command it's about to run

## Design

### New Protocol Messages

| Message | Direction | Purpose |
|---|---|---|
| `START_INTERACTIVE_CMD` | Server → Client | Spawn a PTY process, begin session |
| `INTERACTIVE_OUTPUT` | Client → Server | Stream output chunk from the PTY |
| `SEND_INPUT` | Server → Client | Write text to the PTY's stdin |
| `INTERACTIVE_CMD_DONE` | Client → Server | Process exited, session complete |
| `TERMINATE_CMD` | Server → Client | Kill the process immediately |

### Session Flow

```
Agent                   Server                  Controller Client
  |                       |                           |
  |-- start_interactive --→|                           |
  |   (command="sudo apt   |-- START_INTERACTIVE_CMD --→|
  |    install nginx")     |                           |-- pexpect.spawn() --→
  |                       |                           |
  |                       |←-- INTERACTIVE_OUTPUT -----|  "[sudo] password:"
  |←-- {session_id,       |                           |
  |     output}           |                           |
  |                       |                           |
  |-- send_command_input --→|                           |
  |   (session_id, "pwd\n")|-- SEND_INPUT ------------→|
  |                       |                           |-- child.sendline("pwd")
  |                       |                           |
  |                       |←-- INTERACTIVE_OUTPUT -----|  "Reading package lists..."
  |←-- {output}           |                           |
  |                       |                           |
  |                       |←-- INTERACTIVE_CMD_DONE ---|  (exit_code=0)
  |←-- {final, exit_code} |                           |
```

### Server-Side Architecture

**`projects/services.py`** — Three new service functions:
- `controller_start_interactive_command(project_id, command) → InteractiveCommandResult`
- `controller_send_input(project_id, session_id, input_text) → InteractiveOutputResult`
- `controller_terminate_interactive_command(project_id, session_id) → CommandResult`

The `start_interactive_command` dispatches `START_INTERACTIVE_CMD` and waits for the first `INTERACTIVE_OUTPUT` (the initial prompt/output). It uses the existing dispatch pattern but with a new reply type.

The `send_input` dispatches `SEND_INPUT` and waits for the next `INTERACTIVE_OUTPUT` or `INTERACTIVE_CMD_DONE` (if the process exits after receiving input).

### Controller Client Architecture

**`controller_client/interactive_session.py`** — New module:
- `InteractiveSessionManager` — manages active sessions (max 1 per client)
- `InteractiveSession` — wraps a `pexpect.spawn()` child with:
  - Output collection (via `pexpect.expect` with timeout)
  - Input sending (via `child.sendline()`)
  - Lifecycle management (spawn, kill, check alive)
  - Timeout enforcement

### Agent Tool Definitions

```
start_interactive_command(command: str) → session_id + initial output
send_command_input(session_id: str, input_text: str) → output after input
```

## Constraints

- `pexpect` is Linux/macOS only. Since controller clients run on Linux (Ubuntu 24.04) or macOS, this is acceptable. Windows support is out of scope.
- Max 1 active interactive session per project to avoid complexity.
- Session timeout default: 300 seconds (5 minutes), configurable via `INTERACTIVE_CMD_TIMEOUT_SECONDS` in settings.
- Output chunks are capped at 64KB per message to avoid overwhelming the WebSocket.
- The agent must explicitly use `start_interactive_command` — we do NOT auto-detect interactivity.

## Verification

1. Agent runs `sudo apt install nginx` via `start_interactive_command`
2. Agent sees `[sudo] password:` in the output
3. Agent sends the password via `send_command_input`
4. Agent sees installation progress output
5. Process completes, agent sees exit code 0
6. Non-interactive `execute_command` still works unchanged
7. Session auto-terminates after timeout if agent abandons it
8. Agent can explicitly kill a hung session via `send_command_input` with empty input + terminate flag, or the session auto-expires
