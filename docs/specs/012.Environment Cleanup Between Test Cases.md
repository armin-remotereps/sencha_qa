# 012. Environment Cleanup Between Test Cases

## Problem

When a test case finishes execution (pass, fail, timeout, or cancellation), all applications opened during the test — browsers, VS Code, terminals, file managers, etc. — remain running on the remote machine. The next test case starts on a dirty desktop, which causes:

- **Interference**: Leftover windows from previous tests confuse the AI agent's screenshot analysis
- **State leakage**: A browser still logged in from test case 1 affects test case 2's login flow
- **Resource exhaustion**: Over a 50-test run, accumulated processes consume all memory/CPU
- **Non-deterministic results**: Tests depend on the order they run, making failures hard to reproduce

## Solution

Track the PIDs of every process the controller client spawns during a test case, and kill exactly those processes at cleanup time. This is surgical — we only kill what we started, never anything the user had running before the test.

## Requirements

### R1: PID tracking on the controller client

A new `ProcessTracker` component on the controller client records the PID of every process spawned during a test case:

- **`launch_app`** — `subprocess.Popen()` returns a PID, currently discarded. Register it.
- **Background commands** — `subprocess.Popen()` with `start_new_session=True` returns a PID, currently discarded. Register it.
- **Interactive sessions** — `pexpect.spawn()` exposes `.pid`. Register it.

The Playwright browser is **not** tracked by PID — it's managed by `BrowserSession.close()` which already handles its own process cleanup gracefully.

`ProcessTracker` exposes:
- `register(pid: int) -> None` — add a PID to the tracking set
- `kill_all() -> list[int]` — kill all tracked PIDs (and their process groups via `os.killpg`), return the list of PIDs that were actually killed, then clear the set
- `clear() -> None` — reset the tracker without killing anything

### R2: New controller action — `cleanup_environment`

The server can dispatch a `cleanup_environment` action to the controller client. The controller performs:

1. **Close the Playwright browser session** — `browser_session.close()` (already exists). Resets internal state so the next `ensure_page()` creates a fresh instance.
2. **Terminate interactive shell sessions** — `session_manager.terminate_all()` (already exists).
3. **Kill all tracked processes** — `process_tracker.kill_all()`. Uses `os.killpg(pid, signal.SIGTERM)` first, then `SIGKILL` after a short grace period for any survivors. Kills the entire process group so child processes don't linger.
4. **Clear the downloads folder** — remove all files in `~/Downloads/`.

Returns an `ActionResult` summarizing what was cleaned (e.g., "Closed browser, terminated 1 session, killed 3 tracked processes, cleared 5 download files").

### R3: Automatic cleanup in test execution flow

Called automatically in `execute_test_run_test_case()`:

1. **Before the orchestrator runs** — ensures a clean slate even if the previous test's cleanup failed.
2. **In the `finally` block** — ensures cleanup runs regardless of outcome (success, failure, timeout, cancellation, crash).

Cleanup failures are logged but **never** propagate — they must not affect the test result or block the next test case.

### R4: Cleanup timeout

Dedicated timeout: 30 seconds (configurable via `CLEANUP_TIMEOUT_SECONDS`). If the controller doesn't respond in time, the server logs a warning and moves on.

### R5: Non-breaking change

- Additive — no existing protocol messages or tools change
- Backward-compatible — old controller clients that don't support the action get a logged warning
- The AI agent does NOT have access to cleanup as a tool — it's infrastructure

## Design

### ProcessTracker

New file: `controller_client/process_tracker.py`

```python
class ProcessTracker:
    def __init__(self) -> None:
        self._pids: set[int] = set()

    def register(self, pid: int) -> None:
        self._pids.add(pid)

    def kill_all(self) -> list[int]:
        """Kill all tracked PIDs + their child trees, return those actually killed."""
        killed: list[int] = []
        if platform.system() == "Windows":
            killed = self._kill_all_windows()
        else:
            killed = self._kill_all_posix()
        self._pids.clear()
        return killed

    def _kill_all_posix(self) -> list[int]:
        """Linux/macOS: kill via process group (SIGTERM, then SIGKILL)."""
        killed: list[int] = []
        for pid in self._pids:
            try:
                os.killpg(os.getpgid(pid), signal.SIGTERM)
                killed.append(pid)
            except ProcessLookupError:
                pass
            except PermissionError:
                logger.warning("No permission to kill PID %d", pid)
        time.sleep(2)
        for pid in self._pids:
            try:
                os.killpg(os.getpgid(pid), signal.SIGKILL)
            except (ProcessLookupError, PermissionError):
                pass
        return killed

    def _kill_all_windows(self) -> list[int]:
        """Windows: kill via taskkill /T (process tree)."""
        killed: list[int] = []
        for pid in self._pids:
            result = subprocess.run(
                ["taskkill", "/F", "/T", "/PID", str(pid)],
                capture_output=True,
            )
            if result.returncode == 0:
                killed.append(pid)
        return killed

    def clear(self) -> None:
        self._pids.clear()
```

### Where PIDs get registered

| Spawn site | File | Current behavior | Change |
|---|---|---|---|
| `_launch_app()` | `controller_client/app_launcher.py` | `Popen()` result discarded | Pass `process_tracker`, call `tracker.register(proc.pid)` |
| `_execute_background_command()` | `controller_client/executor.py` | `Popen()` result discarded | Pass `process_tracker`, call `tracker.register(proc.pid)` |
| `InteractiveSession.start()` | `controller_client/interactive_session.py` | `pexpect.spawn()` PID available but unused | After `spawn()`, call `tracker.register(self._child.pid)` |

The `ProcessTracker` instance lives on `ControllerClient` (alongside `BrowserSession` and `InteractiveSessionManager`) and gets passed down to executor functions.

### Protocol Message

| Message | Direction | Purpose |
|---|---|---|
| `CLEANUP_ENVIRONMENT` | Server → Client | Reset the environment between test cases |

**Payload (Server → Client):**
```json
{
  "type": "cleanup_environment",
  "request_id": "uuid"
}
```

No payload fields needed — the controller knows what it spawned.

**Response (Client → Server):**
Standard `ACTION_RESULT`:
```json
{
  "type": "action_result",
  "request_id": "uuid",
  "success": true,
  "message": "Cleanup complete: closed browser, terminated 1 session, killed 3 tracked PIDs [1234, 5678, 9012], cleared 5 files from ~/Downloads",
  "duration_ms": 3250.5
}
```

### Controller Client Cleanup

New file: `controller_client/cleanup.py`

```python
def execute_cleanup(
    browser_session: BrowserSession,
    session_manager: InteractiveSessionManager,
    process_tracker: ProcessTracker,
) -> ActionResultPayload:
    """Kill everything we spawned during this test case."""
    summary_parts: list[str] = []

    # 1. Close Playwright browser
    browser_session.close()
    summary_parts.append("closed browser")

    # 2. Terminate interactive sessions
    session_manager.terminate_all()
    summary_parts.append("terminated interactive sessions")

    # 3. Kill all tracked processes
    killed = process_tracker.kill_all()
    if killed:
        summary_parts.append(f"killed {len(killed)} tracked PIDs {killed}")

    # 4. Clear ~/Downloads
    cleared = _clear_downloads_folder()
    summary_parts.append(f"cleared {cleared} download files")

    return ActionResultPayload(
        success=True,
        message=f"Cleanup complete: {', '.join(summary_parts)}",
        duration_ms=...,
    )
```

### Server-Side Integration

**`projects/services.py`** — New function:
```python
def controller_cleanup_environment(project_id: int) -> dict[str, Any]:
    """Dispatch cleanup_environment to the controller client."""
```

Uses `_dispatch_controller_action` with `CLEANUP_TIMEOUT_SECONDS`.

**`projects/services.py`** — Modified `execute_test_run_test_case`:
```python
def execute_test_run_test_case(pivot_id: int) -> None:
    pivot = _fetch_pivot(pivot_id)
    ...
    try:
        _wait_for_agent_connection(...)
        _safe_cleanup(project.id)     # ← clean before
        ...
        result = run_orchestrator(...)
        _finalize_pivot(pivot, result)
    except ...:
        ...
    finally:
        _safe_cleanup(project.id)     # ← clean after
        _update_test_run_status_if_needed(pivot.test_run)
```

`_safe_cleanup` wraps `controller_cleanup_environment` in a try/except that logs warnings but never raises.

### Files Changed

| File | Change |
|---|---|
| `controller_client/process_tracker.py` | **New file** — `ProcessTracker` class |
| `controller_client/cleanup.py` | **New file** — `execute_cleanup()` function |
| `controller_client/protocol.py` | Add `CLEANUP_ENVIRONMENT` to `MessageType` |
| `controller_client/client.py` | Add `ProcessTracker` instance, add `_handle_cleanup_environment` handler, pass tracker to executor functions |
| `controller_client/executor.py` | `_execute_background_command()` accepts `ProcessTracker`, registers PID |
| `controller_client/app_launcher.py` | `_launch_app()` accepts `ProcessTracker`, registers PID |
| `controller_client/interactive_session.py` | `InteractiveSession.start()` accepts `ProcessTracker`, registers PID |
| `projects/controller_protocol.py` | Add `CleanupEnvironmentActionEvent`, register in `ActionTypeRegistry` |
| `projects/services.py` | Add `controller_cleanup_environment()`, add `_safe_cleanup()`, modify `execute_test_run_test_case()` |
| `auto_tester/settings.py` | Add `CLEANUP_TIMEOUT_SECONDS` |
| `example.env` | Add `CLEANUP_TIMEOUT_SECONDS` |

### New Settings

```env
# Environment cleanup between test cases
CLEANUP_TIMEOUT_SECONDS=30
```

No `CLEANUP_PROCESS_NAMES` needed — we track exactly what we spawn.

## Constraints

- Cleanup must never raise — failures are logged as warnings, execution continues
- Cleanup must be fast (< 30s)
- The AI agent has no access to `cleanup_environment` — it's infrastructure, not a tool
- **Linux/macOS**: `os.killpg` kills the entire process group, so child processes also get cleaned
- **Windows**: `taskkill /F /T /PID` kills the process tree (equivalent behavior)
- `ProcessLookupError` is expected and silenced — processes may have exited naturally
- `BrowserSession.close()` resets internal state; the next `ensure_page()` bootstraps a fresh Playwright instance (existing behavior)
- The `ProcessTracker` is thread-safe (uses a lock) since executor functions run in `asyncio.to_thread`

## Verification

1. Run a test case that launches an app via `launch_app` and runs a background command — verify both PIDs are tracked and killed after the test
2. Run two test cases in sequence — verify the second test starts with a clean desktop
3. Simulate a test case timeout — verify cleanup still runs in the `finally` block
4. Verify cleanup handles already-dead processes gracefully (no crash on `ProcessLookupError`)
5. Verify cleanup doesn't affect the test result (a cleanup failure on a passed test doesn't flip it to failed)
6. Verify the downloads folder is empty at the start of each test case
7. Verify backward compatibility — server logs a warning if the controller doesn't support the action
